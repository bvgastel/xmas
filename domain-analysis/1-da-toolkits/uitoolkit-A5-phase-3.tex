\section{Phase 3 Final selection}

\subsection{UI toolkit requirements} 

Table \ref{tab:uitool-requirements} shows the tool kit requirements. 
The main requirements were already tackeled (platform, C++, free software, community).
The final comparison takes the remaining tool kit requirements into account.

\begin{center}
	\small\sf
	\begin{tabular}{c|p{8em}|p{8em}|cccc|}
		\hline
		{\bf id} & {\bf req}        & {\bf fitness}     & {\bf GTK+} & {\bf Qt} & {\bf WxWidgets} & {\bf FLTK}\\
		\hline
		    7    & Ease of use      & reputation        & +                      & + & + & +\\
		    8    & Ease of learning & rep \& tutorials  & +                      & + & + & +\\
		    9    & Documentation    & website \& rep    & +                      & + & + &  \\
		    10   & Observer pattern & signal processing & +                      & + & + &  \\
		    14   & Concurrency      & support for conc. & +                      & + & + &  \\
		    15   & Conc. observer   & is it possible?   & + \footnote{messaging} & + &   &  \\
	
	\end{tabular}
	\captionof{table}{Final comparison of selected toolkits}
\end{center}

\paragraph{Use and learning.} We can only measure the requirements for ease of use
and learning subjectively. This is an experience result and changes in time:
any tool kit becomes easy to use and learn after enough experience using it. So the only
measure that we could use is reputation, plus tutorials for ease of learning. 

\paragraph{Use of reputation.} Although subjective, the cumulative criticism and opinions
indicate real quality. Neither of the systems have bad rep on any
of the subjectively measurable qualities (7, 8 and 9). Also, the main website for
the tool kit easily revealed the available documentation. The hypothesis that any one 
lacks in ease of use, learning or in documentation seems unwarranted. 

\paragraph{Observer pattern.} For our UI the observer pattern is important in two ways.
Firstly, all signals from the user interface should relay flawlessly to modules, even if
they execute concurrently. Secondly, any change of status or content in the modules,
even concurrent modules should relay flawlessly to the user interface thread. Measuring
this is a question of checking the docs and asking around. 

The tool kit Qt explicitly allows some thread to receive signals from different
threads or processes, and will execute the method in the thread belonging to the slot.
For all tool kits the usual concurrency issues apply with respect to sharing of data objects.
