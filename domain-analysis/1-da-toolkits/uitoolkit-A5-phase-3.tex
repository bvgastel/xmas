\section{Phase 3 Final selection}

\subsection{Phase 3 selection results} 

Table \ref{tab:uitool-requirements} shows the tool kit requirements.  The final
comparison takes the remaining tool kit requirements into account.

\vspace{1em}
\begin{minipage}{.95\textwidth}
	\begin{center}
		\small\sf
		\begin{tabular}{|c|p{9em}|p{8em}|cccc|}
			\hline
			{\bf id} & {\bf req}             & {\bf fitness}           & {\bf GTK+} & {\bf Qt} & {\bf Wx} & {\bf FLTK}\\
			\hline
			    7    & Ease of use           & reputation              & +                      & + & + & +\\
			    8    & Ease of learning      & rep \& tutorials        & +                      & + & + & +\\
			    9    & Documentation         & website \& rep          & +                      & + & + & + \\
			    10   & Observer pattern      & signal processing       & +                      & + & + & 
			    +\footnote{using standard C++ or another library like boost\label{fn:c++}} \\
			    14   & Concurrency           & support for concurrency & +                      & + & + & +\footref{fn:c++} \\
			    15   & Concurrent observer   & is it possible?         & +                      & + & + & +\footref{fn:c++} \\
				\hline
		\end{tabular}
		\captionof{table}{Final comparison of selected tool kits}
		\label{tab:final-comparison}
	\end{center}
\end{minipage}

\paragraph{Use and learning.} We can only measure the requirements for ease of
use and learning subjectively. This is an experience result and changes in
time: any tool kit becomes easy to use and learn after enough experience using
it. So the only measure that we could use is reputation, plus tutorials for
ease of learning. 

\paragraph{Use of reputation.} Although subjective, the cumulative criticism
and opinions indicate real quality. Neither of the systems have bad rep on any
of the subjectively measurable qualities (7, 8 and 9). Also, the main website
for the tool kit easily revealed the available documentation. The assumption
that any one of these tool kits lacks in ease of use, learning or in
documentation can be rejected on the basis of experience and reputation. 

\paragraph{Observer pattern.} The observer pattern is important in two ways.
First, all signals from the user interface should relay flawlessly to modules,
even if they execute concurrently. Secondly, any change of status or content in
the modules, even concurrent modules should relay flawlessly to the user
interface thread. Measuring this is a question of checking the docs and asking
around. 


\subsection{Phase 3 selection analysis}

Table \ref{tab:final-comparison} shows that tool kit requirements 7, 8 and 9
are satisfactory for all. The observer pattern and concurrent process
communication is not as simple. In summary, Qt GTK+ and WxWdiget all suffice
without modification. For FLTK we need to use one of the available cross
platform libraries for concurrency and one for the observer pattern, like
boost.

As all packages can fulfil the requirements the question is, what distinguishes
these tool kits and on what basis should we choose? The short answer is: they
all suffice. So the choice is no longer one of user interface requirements, but
one of preference. 

