\documentclass[a4paper, draft]{article}
\begin{document}
Wat naar mijn idee het belangrijkst is, is om definitief vast te leggen welke richting we op gaan, refactoren of opnieuw bouwen. De beslissing lijkt eigenlijk al genomen, Bernard liet tijdens het overleg merken dat opnieuw bouwen sterk zijn voorkeur had. We konden bijv. wel toegang krijgen tot de source code van WickedXmas maar hij deed dat wel met de waarschuwing dat de kwaliteit van de code erg laag was. We zouden dus slechte ideeen kunnen opdoen door de source code te bestuderen. Verder leken Bernard (en Freek?) er al uit te zijn dat integratie van de tools, de belangrijkste prio, moeilijk te realiseren is met c\# als taal. Waarom refactoren dan toch als mogelijkheid wordt genoemd hebben we onszelf al eerder afgevraagd.

Misschien was dat bedoeld om ons de kans te geven onze vaardigheden in het maken van een goede afweging te laten zien. In dat geval moeten we aangeven waarom we de ene of de andere keuze voorstellen (lees: waarom we opnieuw opbouwen voorstellen). We kunnen bijvoorbeeld aangeven dat de ontwerptool in c++ maken garandeert dat de integratie met de tools mogelijk is (KAN het?), en dat deze garantie belangrijker lijkt dan het risico of onze kennis van c++ van voldoende niveau is/wordt (kunnen WIJ het?). Dit in combinatie met de voorkeur van de opdrachtgever voor herbouw en de keuze voor een taal en toolkit waarbij cross-platform gebruik vanaf het begin een aandachtspunt is geweest.

We kunnen natuurlijk ook uitgebreider te werk gaan en voorstellen om eerst de staat van de huidige tool te analyseren. Aan de hand daarvan kunnen we dan beter argumenteren of refactoren haalbaar is of dat herbouw nodig is. Maar zoals boven geschreven, Bernard en Freek lijken deze analyse al gedaan te hebben en tot een conclusie te zijn gekomen. Het zou zonde zijn om hier dan veel tijd aan te verspillen terwijl we het antwoord al weten.


Hoewel het dus al duidelijk lijkt moeten we wel snel definitief een keuze maken. De keuze voor refactoren dan wel opnieuw bouwen heeft veel gevolgen voor de planning. De activiteiten die we precies moeten uitvoeren zullen natuurlijk zeer verschillend zijn afhankelijk van de keuze. Belangrijker nog is dat ik me kan voorstellen dat zelfs de te volgen projectaanpak drastisch anders kan zijn.


Nog iets over de software process modellen:

In tegenstelling tot de meeste softwareprojecten lijken de requirements hier wel duidelijk te zijn. De huidige tool wordt al gebruikt en de onderzoekers weten wat ze er wel en niet van kunnen verwachten, belangrijk is dat wij de requirements ook te weten komen. Als we een Agile aanpak kiezen is dit wel iets waar we rekening mee moeten houden. Changing requirements spelen geen grote rol en een nadeel van agile en andere 'evolutionary development' methoden luidt: 'Systems are often poorly structured. Continual change tends to corrupt the software structure. Incorporating software changes becomes increasingly difficult and costly.' Dit klinkt als het problemen van de huidige tool. De hele extreme vormen van Agile (bijv. Extreme programming), waarbij tijdens elke iteratie alleen wordt gekeken naar de problemen die op dat moment spelen, lijken mij dus niet geschikt.
\end{document}
