\documentclass[a4paper]{article}

% common import
\input{../../../papers/common.tex}

% use all the default imports and theorem definitions
\default

% use a somewhat different layout
\dutch

\development

\title{A technical description of the \xmas symbolic productivity checker tool}
\author{Bernard van Gastel}

\begin{document}
\maketitle

{\abstract
Productivity for message dependent routing communication fabric is hard to validate for a given network. In order to avoid a full simulation including all properties of the network, using a formal proving framework we have deduced multiple simpeler properties that combined constitute a full productivity property. In order to check these properties we have created a custom \cpp tool that symbolically validates all these properties and hence prove productivity for a given network.
}

\section{Introduction}


\section{Symbolic packets}
To efficiently calculate the effect of operations on symbolic values, the tool implements a number of custom kind of fields.
\begin{enumerate}
\item Enumerate kind. Labels signify symbolic values. As there are no concrete values, enumerate types do not have addition or multiplication defined on them. However a mapping converting a value in another value can be defined. %A set of all possible distinct values. %No addition or multiplication on enumerate types is supported.
\item Interval kind (integer). A number of integer arithmetic operations are supported on these types, like addition and subtraction, comparison, greater than, less than, etc. Intervals have a lower bound $l$ and upper bound $h$, both represented as an integer for which $l \leq h$. Modulo and multiplication is not supported as it can result in multiple non-continuous regions.
\end{enumerate}

Using these field kinds a \emph{symbolic packet} can be defined as a set of these fields kinds which all have an unique label. E.g. a packet with two fields, with destination of the interval kind with a value between 0 and 13, and type of the enumerate kind with a symbolic value request or response: \[
	\{destination \to [1..12],\ type \to \{REQ,RSP\}\}
\]

The effect of \xmas primitives can be expressed using set operators, specifically the intersection and difference operators. A symbolic packet signifies a set of possible values, a switching function on a \xmas-switch signifies a set of possible values that will propagate to the designated channel. An expression on a \xmas-source component signifies which packet will be inserted at this point, which constitute a set of possible values that can be injected.

The supported primitive operations on these symbolic packets (and therefore the field kinds) are:
\begin{itemize}
\item \emph{Intersection}. 
\item \emph{Difference}.
\item \emph{Combine multiple packets into one packet}.
\end{itemize}

The last one is needed to reduce the runtime of the algorithm as it reduces the number of propagation steps needed. There are some other minor operations (e.g. hash function and printing a string representation) that are not essential to the algorithm but aid in execution speed and the debugging effort.

\todo{Example hoe de sets operaties werken aan de hand van een switch}

\section{Network representation}
Each network consists of a set of \emph{components}, each component is of one of the following component types: source, sink, queue, function, switch, merge, fork, join. Each component can have multiple \emph{ports} associated with it. A port can be either an input or an output port. Each port can be connected to one other port (of the different type, statically type checked by the compiler). Two ports together constitute a communication channel between two components. In order to easily debug the network, each component should have a unique name.

To maximise the flexibility of the network data structure two aspects are important. Foremost, the data structure supports the \emph{visitor} design pattern, enabling the separating of the algorithm executing on a data structure and the data structure itself. Secondly, each object of the network can have algorithm specific data structure attached to it. This avoids costly lookups and enables easier algorithm design.

A network can be read from a JSON file format. The JSON representation of components is straightforward, but for the representation of the functions as used in the definitions of the \xmas switch, join and function components. We have implemented a simple mathematical expression based syntax, depending on the data-type and the context as it is used in. For example the following definition originates from the code of an 8 node spidergon network, which work on the interval field type. The input field is specified as variable \lstinline|in|.

% (in-range (mod (- in 4) 8) 0 2)
\begin{lstlisting}[numbers=none]
in > 4 && in <= 6
\end{lstlisting}

This example specifies which packets will go to the right channel of the fourth node of the Spidergon.

\section{Algorithms}

We have implemented a number of algorithms on the data structure. They consists of:
\begin{itemize}
\item Syntactic correctness.
\item Combinatorial cycles.
\item Symbolic types inference.
\item Message specification.
\item \todo{Deadlock checker}.
\end{itemize}

\subsection{Syntactic correctness}
All ports should be connected, with input ports only connected to a output port and visa versa.

\subsection{Combinatorial cycle detection}
The network only produces stable and consistent output if there are no combinatorial cycles. This is done using a standard text-book cycle detection algorithm.

\subsection{Symbolic Types}

\subsection{Message specification}

\subsection{Deadlock checker}


\end{document}